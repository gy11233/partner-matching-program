# 伙伴匹配系统学习笔记

## 需求分析
1. 用户添加标签，标签的分类
2. 主动搜索：用户更加标签搜索其他用户
    1. redis缓存
3. 组队：创建队伍，加入队伍，查询队伍，邀请其他人
4. 允许用户修改标签
5. 推荐： 相似度计算算法+本地分布式计算
---
### v1.0.0
初始版本，完成基本功能
1. 用户功能
   1. 用户登录 todo:增加用户注册
   2. 修改用户信息 todo:增加上传头像功能，规范用户信息显示，如性别
2. 标签匹配功能
   1. 按照标签搜索用户（搜索速度非常慢）todo:速度优化
   2. 按照标签匹配伙伴
      - 正常模式只能按照标签推荐id靠前的用户 todo:随机推荐
      - 心动模式匹配速度较慢 todo:优化速度和推荐算法
3. 队伍操作 
   1. 创建队伍，查询加入队伍  todo:私密的队伍在哪里查到
   2. 搜索队伍(公开队伍、私密队伍、按照名称或者描述搜索队伍)
   3. todo:队伍需要可以聊天
4. 数据库全都是假数据，需要造一些真的数据
5. 没有统一的权限管理

### v1.1.0
目标
1. 增加用户注册功能
2. 增加聊天功能  可以参考https://github.com/Zhaosml/PartnerMatching.git
3. 修改匹配算法 knn可能会参考到https://github.com/dnwwdwd/homieMatching/tree/master
4. 解决部分查询慢的问题

### v1.2.0
目标
1. aop加配置注解实现全局拦截和日志功能
2. 解决redis的各种问题
    - 缓存穿透
    - 缓存雪崩 
    参考   http://doc.ochiamalu.top/

## 技术栈
### 前端
1. Vue3 开发框架
2. Vant UI
3. Vite 打包工具
4. Nginx单机部署

### 后端
1. java编程语言+springboot框架
2. springMVc + Mybatis + MyBatis Plus
3. MySQL数据库
4. Redis缓存
5. Swagger + Knife4j接口文档


## 主要流程

### 第一期任务
1. 数据库表设计
   1. 标签表
   2. 用户表
2. 开发后端 根据标签搜索用户
3. 后端整合Swagger+Knife4j接口文档
4. 存量用户信息导入
5. 前后端联调 使用@CrossOrigin注解

### 第二期任务
1. 页面和功能开发 前端
2. 改造用户中心，把单机登录改成分布式session登录

### 第三期任务
1. 用户修改页面的后端开发
2. 开发主页（默认推荐和自己兴趣相当的用户）
   - 开发/user/recommend后端接口
   - 导入数据 尽量一个量级一个量级增加 分批导入 写程序导入 更可控
3. 优化主页的性能（缓存+定时任务）

### 第四期任务
1. 分布式锁

### 第五期任务
1. 组队功能


## 模块实现

### 数据库表设计

#### 1. 标签表
建议用标签不用分类 更加灵活

**标签的设计**
性别：男女  
方向：java  c++ go  
目标： 考研 求职 球招 社招 考公 竞赛  
段位： 入门 中级 高级  
身份： 大一 大二 大三 大四 研一 研二 研三   
状态： 单身 已婚 有对象
【用户自己定义标签】
如果标签固定的 是不是可以直接存在后端？？？

**字段**

id int 主键   
标签名 varchar 非空 （**必须唯一 唯一索引**）
上传标签的用户id user_id int  （如果要要根据userid查看已经上传标签的话，最好加上 普通索引）
父标签id parent_id int  
是否为父标签 is_parent tinyint(0, 1) **尽量不要用布尔 不灵活**  
创建时间 create_time   datetime
更新时间 update_time   datetime
是否删除 is_delete tinyint(0,1)

考虑的问题 怎么查询标签并分组？ 按照父标签id分组
根据父标签查询子标签？查服标签的id

标签字段设计的一般都有的属性
id 创建时间 更新时间 是否删除

#### 2. 用户表
用户可以知道有哪些标签 一对多的关系
   1. 用户表中加tags标签 【‘java’, '男'】存json字符串 ✅
      - 优点：查询用户标签比较方便 不用新建关联表，（标签是固有属性 除了系统其他系统页可能用）
        之后随着人数增多 20w+ 效率低了 也可以考虑用缓存的技术来缓存java标签下的所有用户
      - 缺点：通过标签查询用户不方便 用like效率很低 更新用户表或者更新标签很麻烦
   2. 关联表 记录用户和标签的关系 
      - 优点：正反查都很方便
      - 重点：企业大型项目开发中尽量减少关联查询，会应用查询系统

**字段**

id bigint 自增 主键  
用户昵称 username varchar  
用户账号 user_account  
用户头像 user_url  
用户性别 gender  
用户密码 password varchar  
电话 phone  
邮箱 email  
用户状态 user_status  
创建时间 create_time   datetime  
更新时间 update_time   datetime  
是否删除 is_delete tinyint(0,1)  
用户角色 user_role  
星球编号 planet_code  
标签 tags  varchar(1024)


### 主要功能

#### 用户中心提供用户检索 登陆 修改 鉴权
TODO: 细致分析用户中中心


#### 通过标签搜索用户功能
1. 允许用户输入标签，多个标签都存在才搜索出来 and  like "%java%" and like "%C++" 
2. 允许用户传入多个标签，只要有一个就搜索出来 or  like "%java%" or like "%C++"

两种查询方法：
1. sql查询
2. 内存查询MybatisX-Generator插件生成关于表的基本代码

> tips:可以通过MybatisX-Generator操作

**实现思路**
service实现 `searchUsersByTags`
- 标签不能为空 否则返回异常
- 用sql的方式实现
- 用内存的方式实现（可以通过并发）

#### 用户注册 登陆 （解决分布式登录问题）
模拟分布式登录：
```shell
java -jar 项目jar包 --server.port=8081
```
##### 服务器A登录后，请求发送到服务器B不认识用户
用户在A登录，所以session存储在了A中，请求B时，B没有用户信息
解决方案：共享存储，把用户信息放在**公共存储**中
如何共享存储？
1. mysql
2. redis ✅ 用户信息读取/是否登录的判断及其**频繁** 基于内存 读写性能很高 单机qps 5w-10w
3. 文件服务器 ceph

##### redis安装与使用
> https://blog.csdn.net/realize_dream/article/details/106227622

版本 redis 7.2.5 
管理工具 quick redis 

基本命令:
```shell
brew services start redis
redis-cli
redis-cli -h 127.0.0.1 -p 6379
redis-cli shutdown
```
引入mvn包 
配置application.yml
- 配置redis
- 配置session存储方式为redis store-type: redis 从redis中读写session

#### 修改用户信息
1. 判断参数是否为空
23可以写到service层
2. 校验权限
3. 触发更新

----
### 后端整合Swagger+Knife4j接口文档
每条接口内容
- 请求参数
- 响应参数
  - 错误码
- 接口地址
- 接口名称
- 请求类型
- 请求格式
- 备注

swagger https://blog.csdn.net/hadues/article/details/123753888
1. maven中引入
2. 配置config下文件 在SwaggerConfig类上加@Profile({"dev", "test"})注解 不暴露接口给外部
3. 配置需要生成接口文档的包
4. 配置application.yml(因为版本兼容带来的问题)

### 批量导入数据
1. 写程序导入
2. 用mybatis-plus的批量导入加速
3. 数据量大了之后采用分页操作显示主页信息

### 主页性能优化
80w数据用了分页之后还是0.2s 有卡顿，如果超出1s就是比较慢的 数据库慢 
预先把数据查出来放到一个更快读取的地方（缓存）

预加载 定时更新缓存  分布式锁 控制同一时间只有一台及其去执行定时任务

##### 数据查询慢怎么办？用缓存
缓存：提前把数据取出来保存好，通常保存到读写更快的介质中，比如内存

**缓存的实现**
- redis 分布式
- memcached 分布式
- etcd  云原生架构的分布式存储 存储配置 扩容能力强
------
- ehcache 单机
- 本地缓存 java内存map
- caffeine java内存缓存 高性能
- google guava
单机缓存 在多服务器的时候可能出现数据不一致的情况

**redis**
> NoSQL数据库

key-value存储系统

**java里的实现方式**
- spring data redis (推荐)
  - spring data一组通用的数据访问框架，定义了增删改查的接口
  - spring data redis是针对redis的实现类
- jedis
- redisson

###### 具体实现
1. **设计缓存key**
    systemId:moduleId:func:<options> (不和别人冲突)
    
    partner:user:recommend:userId 
2. **实现redis缓存存储** 
   - 如果没有登录的直接用default，登录的用户记录自己的缓存（之后可以扩展成有匹配的推荐）
   - 效果：没有用redis之前加载时间200ms左右 改进后第一个用户200ms，之后的用户20ms左右
   - 问题：第一个用户还是很慢

#### 缓存预热
###### 缓存预热优缺点
- 优点
  - 让用户始终访问很快
- 缺点
  - 增加开发成本
  - 预热的时间和时机如果错了，可能缓存的数据不对
  - 需要占用额外空间
###### 怎么缓存预热
- 定时
  - 启动类@EnableScheduling 需要定时执行的方法添加@Scheduled，指定corn表达式
- 模拟触发（手动触发）
- 注意的点
  - 缓存预热的意义 （新增少，总用户多）
  - 缓存的空间不能占有太大，要预留给其他缓存空间
  - 预热周期 1/天
###### 定时任务实现
1. spring scheduler  springboot 默认整合
2. quartz 独立于Spring的定时任务
3. XX-job ==可以放在后续实现和源码阅读任务==


#### 分布式锁 控制定时任务的执行
可能出现脏数据（重复插入） 浪累资源

**控制定时任务在同一时间只有一个服务器执行**

可能方法：
- 分离定时任务和主程序，只在一个服务器运行定时任务  成本比较大
- 写死配置，每个服务器都执行定时任务，但只有ip符合配置的服务器才真正执行业务逻辑 成本低 但是ip可能是不固定的，改起来很麻烦
- 动态配置，但只有ip符合配置的服务器才真正执行业务逻辑，配置可以很方便更新(代码无需重启)
  - 数据库
  - Redis
  - 配置中心（Nacos, Apollo, Spring Cloud Config）
  问题 服务器多了还是需要修改
- 分布式锁，只有抢到锁的服务器才能真正执行定时任务业务逻辑  增加成本 但是不用手动配置，多少服务器都一样

**实现方法**

java实现锁：synchronized 关键字  
问题：只对单个JVM有效

**为啥需要分布式锁**
1. 有限资源情况下，控制同一时间（段）只有某些线程（用户或者服务器）可以访问到资源
2. 单个锁只对单个JVM有效

##### 分布式锁实现的关键
**抢锁机制** 同一时间只有一个用户可以抢到锁

数据库实现：先来的人先把数据改成自己的标识（服务器ip）后来的人发现标识已经存在，就抢锁失败，继续等待

- zookeeper实现 （不推荐）
- MySQL数据库：select for update行级锁  todo:==乐观锁==自己后面考虑
- Redis:读写速度快，支持**setnx** lua脚本 ✅

**Redis实现注意的问题**
1. 用完锁释放
2. 锁**一定**要加过期时间
3. 如果方法执行中锁提前过期？
   - 还是会出现多个方法同时执行的情况
   - 连锁效应：释放了别人的锁
    解决方案：续期
4. 释放锁的时候，先判断了是自己的锁，如果锁过期，还是可能释放其他人的锁
5. Redis是集群的情况，如果保证数据一致？ 红锁

**Redis+lua脚本实行** 保证原子操作

##### Redisson实现分布式锁
java客户端，数据网络 
实现了很多java里支持的接口和数据接口 

Redisson是一个java操作Redis的客户端，提供了大量分布式数据集来简化对Redis的操作和使用，
可以让开发者像是使用本地集合一样操作Redis，完全感知不到Redis存在

partner:precachejob:docache:lock

- waitTime设置为0 只抢一次
- 释放锁写在finally里
- redisson提供了续期机制->看门口机制 开一个监听线程，如果方法没执行完自动帮助续期(debug模式会当成宕机 不会续期)


### 组队功能

#### 需求分析
理想应用场景：和别人一起参加竞赛或者做项目，可以发起队伍或者加入别人的队伍

用户可以创建一个队伍，设置队伍的任务、名称（标题）、描述、超时  p0
> 队长、剩余的任务
> 聊天
> 公开 ｜ 加密 ｜私有
> 不展示过期的队伍
> **一个人最多可以创建5个人**

展示队伍列表，根据标签或者名称搜索队伍 p0 信息流中不展示已经过期的队伍

修改队伍信息

用户可 以加入队伍（其他人 未满 未过期 ） 允许加入多个队伍，但是要有个上限 p0
> 是否需要队长同意？审批

用户可以退出队伍（如果是队长退出，权限转移给第二个加入的用户） p1 
队长可以解散队伍  p0 
分享队伍，邀请其他人加入队伍 p1



#### 实现
库表设计

增删改查

业务逻辑开发

#### 库表设计
队伍表 team
字段：
- id主键 bigint （连续 放url上比较简短 但是怕爬虫）
- name 队伍名称
- description描述
- max_num 最大人数
- expire_time 过期时间
- user_id 用户id
- status 0-公开 1-私有 2-加密
- password 密码
- create_time 创建时间
- update_time
- is_delete

用户-队伍表 user_team
字段
- id主键
- user_id 用户id
- team_id 队伍id
- join_time 加入时间
- create_time 创建时间
- update_time
- is_delete


两个关系
1. 用户加了哪些队伍
2. 队伍有哪些用户

方式
1. 建立用户-队伍关系表 （便于修改，查询性能高一点） ✅
2. 用户表补充已经加入的队伍字段，队伍表补充已经加入的用户字段 （不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）


#### 后端代码完成

##### 为什么需要请求参数包装类
- 请求参数名称/类型和实体类型不一样
- 有一些参数用不到，如果自动生成接口文档增加理解成本
- 多个字段映射到同一个对象

##### 为什么要包装类
- 可能有些字段需要隐藏，不能返回给前端
- 有些字段的某些方法是不关心的

#### 接口设计

##### 创建队伍
用户可以创建一个队伍，设置队伍的任务、名称（标题）、描述、超时  p0
> 队长、剩余的任务
> 聊天
> 公开 ｜ 加密 ｜私有
> 不展示过期的队伍

1. 请求参数是否为空
2. 是否登录 不登录不允许创建
3. 校验信息
   1. 队伍人数>1 <=20
   2. 队伍标题<=20
   3. 描述 <=512
   4. status是否公开  不传默认公开
   5. status如果是加密状态一定要有密码 且密码<=32
   6. 超时时间 > 当前时间
   7. 校验用户最多创建5个队伍
4. 插入队伍信息到队伍表
5. 插入 队伍用户信息到 关系表

通过@Transactional(rollbackFor = Exception.class)注解，进行事务操作，只有队伍信息插入成功 关系表才会同步更新


##### 查询队伍列表

展示队伍列表，根据标签或者**名称**  最大人数等信息 搜索队伍 p0 信息流中不展示已经过期的队伍
1. 从请求参数中取出队伍名称等查询条件，如果存在直接作为查询条件
2. 根据过期时间筛选，不展示过期队伍
3. 关联查询已加入队伍的用户信息，可以展示加入队伍的人员
4. 分页查询
5. 只有管理员才能查看加密和不公开的房间

**实现方式**
- 自己写sql 关联多个表建议自己写sql
- 业务层写关联查询信息  


#### 修改队伍信息
1. 查询队伍是否存在
2. 只有管理员或者队伍创建者可以修改
3. 如果用户传入的新值和老值一致，不用update（可以之后自己实现，降低数据库使用次数 ）
4. 更新成功
5. 如果改成公开，密码可以不用管，如果改成加密，必须要有密码

#### 用户可以加入队伍
1. 用户最多加入5个队伍 （包括了自己创建的队伍）
2. 只能加入未满、未过期
3. 不能重复加入队伍
4. 如果加入队伍是加密的，需要密码
5. 禁止加入私有的队伍
6. 新增队伍关联信息

#### 用户退出队伍
请求参数：队伍id

1. 校验请求参数
2. 校验队伍是否存在
3. 校验是否加入队伍
4. 如果队伍
   1. 只剩下1个人队伍解散
   2. 还有其他人
      1. 如果是队长退出，权限交给第二早加入的用户
      2. 如果不是队长 可以退出 

#### 队长解散队伍
请求参数 队伍id

1. 校验请求参数
2. 校验队伍存在
3. 校验是不是队长
4. 移除关联信息
5. 删除队伍

#### 获取用户已加入的队伍
复用之前的list接口
#### 获取用户已创建的队伍

==todo== 存在的一个问题，team/list接口和查询已加入和创建队伍的接口，和前端功能进一步对接，
现在只能是查询所有的信息，不能公开和私有分开查询


### 随机匹配
> 帮大家更快发现和自己兴趣相同的朋友

#### 匹配一个？还是匹配多个？

- 匹配多个，并按照相似度从高到低

#### 怎么匹配？根据什么匹配？

- 用标签匹配 
> 根据user_team匹配加入相同队伍的用户，或者根据好友推荐队伍

**找到有相似标签的用户**
1. 找到有共同标签最多的用户（Top N）
2. 打分机制 共同标签越多，分数越高，越在前面
3. 如果没有匹配的用户，随机推荐几个用户（降级方案）

> 优先级？
> knn 好像也是可以实现的？？

算法
1. 编辑距离的原理 https://blog.csdn.net/DBC_121/article/details/104198838 ✅ 
2. 余弦相似度算法 （如果需要带权重的计算）

#### 怎么对所有用户匹配，取Top
1. 直接取出所有的用户，依次和当前用户计算分数，取Top N

- 优化方法
  - 不在数据量大的时候输出所有日志
  - Map存了所有的分数信息，占有内存 =>解决：维护一个固定长度的集合，只保留分数最高的几个用户
  - 剔除自己
  - 尽量只查需要的用户
    1. 过滤掉标签为空的用户
    2. 根据部分标签取用户
    3. 只查需要的数据 （比如id和tags）
  - 提前查？
    1. 提前把所有的用户缓存（不适用于经常更新的数据）
    2. 提前运算出来结果缓存（可以根据重点用户进行缓存）

大数据推荐，比如有几亿个商品，有必要查询所有的商品吗？需要对所有的商品计算精确度吗？

> 分析优缺点要从整个项目从0-1进行分析

----
## 优化
1. **队伍权限**仅加入队伍和创建队伍的人能够看到队伍操作按钮（list接口能够获取我加入队伍的状态）
   加入队伍：仅队伍创建人，且未加入队伍的人可见；
   更新队伍：仅创建人可见 ；
   解散队伍：仅创建人可见 ；
    退出队伍：创建人不可见，仅已经加入队伍的人可见 
   - 后端查询出队伍后判断我加入队伍的状态，对list 等多个接口进行调整
   - todo:为啥退出队伍之后刷新 队伍的信息还是可以查到
2. list查询队伍后，查询队伍的成员信息（人数 ）
3. 疯狂点击加入队伍 重复加入的问题 分布式锁 可以扩充看一下秒杀问题的解决方案
    - synchronized 可以直接加在加入队伍的代码逻辑中 问题：但是不同的用户id 或者加入不同的队伍 没必要都一起排队
    - 两个锁：对用户id和队伍id加锁
    - 多服务器的问题怎么办？用分布式锁？
   

## v1.1.0版本优化
### 调整数据库格式，和新版本对应
#### 用户注册
1.  redisLimiterManager.doRateLimiter限流：分布式限流
2. 如果用户信息插入数据库，则计算用户坐标信息并存入Redis， todo:看这部分有没有必要
3. 用户注册后，删除recommend的缓存信息
#### 用户推荐 recommend 接口 
全都改为userVO作为返回类型

#### 用户匹配 match接口
全都改为userVO作为返回类型

#### 用户通过标签搜索接口
全都改为userVO作为返回类型


#### 位置信息
1. 数据库保存经度和纬度
2. 推荐用户时，计算两个用户之间的距离，缓存距离 
3. todo:这里的距离完全依赖缓存吗？还是换到数据库操作
#### 搜索附近用户
1. 依据redis中存储的位置信息
2. 算方圆n km中的用户

#### 我加入和创建的队伍
todo:可以查到所有的队伍，包括隐私和加密的队伍

#### 标签搜索功能
todo: 现在太慢了 需要提速


### 增加聊天功能  
可以参考https://github.com/Zhaosml/PartnerMatching.git
https://blog.csdn.net/weixin_44604118/article/details/90484110?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172354985116800226531987%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=172354985116800226531987&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-90484110-null-null.nonecase&utm_term=%E8%81%8A%E5%A4%A9&spm=1018.2226.3001.4450
webSocket 的知识 https://blog.csdn.net/tuoniaoxs/article/details/116494440
https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers

1. 前端：
   1. 通过/chat/privateChat获取私聊历史记录
   2. 初始化：检验浏览器是否支持websocket服务，并建立一个连接
       ```js
          // 开启一个websocket服务 
           socket = new WebSocket(socketUrl);
          //打开事件 
           socket.onopen = function () {
          startHeartbeat();
          };
       ```
   3. 浏览器端收消息，获得从服务端发送过来的文本消息
        ```js
            websocket.onmessage = function(msg){}
        ```
   4. 定义关闭连接、异常事件
        ```js
        socket.onclose = function () {}
         socket.onerror = function (){}
       ```
   5. 定义消息发送方法send，用`socket.send`来发送消息到服务器

2. **后端**
   1. 准备：
      - pom依赖配置
      - config 配置
          - WebSocketConfig
          - HttpSessionConfig
              - 通过重写modifyHandshake方法，从HandshakeRequest中获取HttpSession，并存入ServerEndpointConfig中，之后就可以获取session信息了
              - 详情看 https://blog.csdn.net/xueyijin/article/details/105692485 https://juejin.cn/post/7202851843487809597
   2. 获取私聊记录的功能放在了chat模块中
   3. **编写WebSocket类 （WebSocket通信核心，所有WebSocket的交互在这里定义）**
   4. 类似于@RequestMapping,WebSocket指定访问地址用@ServerEndpoint(value = "/websocket/{userId}/{teamId}", configurator = HttpSessionConfig.class)
   5. 定义：
      - 定义线程安全的集合来存储session: CopyOnWriteArraySet<Session> SESSIONS; 
      - 定义会话池 Map<String, Session> SESSION_POOL
      - 定义当前信息session和http对话HttpSession httpSession
      - 定义连接数onlineCount 需要线程安全
   6. onOpen websocket连接建立时的操作
      - 接受参数:
        - session(websocket自带的session, 用这个来发信息);
        - userId;
        - teamId;
        - EndpointConfig(用来获取httpsession)
      - 逻辑:
        - 获取当前httpsession并进行参数检查
        - 如果是私人聊天，就加入SESSIONS和SESSION_POOL，并向所有会话池中的人发送所有建立连接的人的信息
   7. OnClose 关闭连接
       - 接受参数：
         - session(websocket自带的session);
         - userId;
         - teamId;
       - 逻辑：
         - 参数检查
         - 如果是私聊，就移除SESSION_POOL和SESSIONS中的信息
   8. OnMessage 接受消息后的操作
      - 参数
        - message 之后会解析成MessageRequest包装类
        - userId
      - 逻辑
        - 过滤到ping的信息
        - 如果聊天类型是私聊，对消息进行封装，并发送给接受消息的用户
        - 保存聊天记录
        - 删除在redis中缓存的信息
   - 多个用户的消息发送逻辑是每个连接的客户端会有其独立的 WebSocket 实例,消息的发送过程往往是 客户端-服务器-客户端，每个websocket都有一个独立的session对象
    所以要把SESSION和线程池SESSION_POLL设置为static 线程安全的 todo:分布式的怎么办？直接存储在redis中
3. chat 模块
   1. 获取私聊信息/chat/privateChat
      - 参数检查
      - 如果有缓存直接读取缓存
      - 没有缓存进行查询 
        - 使用了LambdaQueryWrapper 
      - 存储在缓存中
   2. 保存缓存saveCache
      - 为什么需要缓存：当用户没有退出，但是刷新页面的时候，连接未关闭就重新再次建立，这时候可以直接通过缓存加载数据，或者用户不聊天，只是退出再查看聊天记录
      - <mark>解决雪崩效应的方法！！！ 需要再看
   3. 删除缓存

### 增加好友功能
1. 添加好友
    - 参数检查 自己不能添加自己
    - <mark>对加好友的范围上锁(重点看一下锁的时间设置)，添加事务
2. 列出所有好友 
3. 搜索好友
4. <mark>需不需要缓存来提速
5. 对添加好友部分进行优化，如果已经是好友，添加按键是灰色的，不能添加,未登录不能显示添加按钮，每次添加成功后都删除缓存（因为这时好友状态已经改变）
### 修改匹配算法 
目前没有修改

<mark>之后任务
- 了解余弦分词算法 Jaccard相似度算法
- 了解knn
- 知道这些的区别 目前来看用编辑距离就可以
knn可能会参考到https://github.com/dnwwdwd/homieMatching/tree/master 

### redis list结构实现滑动窗口
1. 如果User未登录，获取默认的key,登录就设置带有用户id的key
2. 如果有缓存，直接读取缓存
3. 如果没有缓存，进行分页查询并将查询结果放入缓存中
4. redis缓存的有效时间设置了1小时，可能和缓存预热的用户推荐页面过期时间有冲突

### 所有redis汇总
1. redis设置session
   1. 通过yml配置session保存到redis中
   2. 可以设置过期时间 spring.session.timeout， 系统默认2.5个小时左右
   3. <mark>redis中保存的信息有待进一步确认
2. 用户推荐页面缓存预热
   1. 每天0点执行，对重要用户的推荐进行缓存
   2. 采用RedissonClient分布式锁，保证只有一个服务器执行预热
3. 用户推荐页面滑动效果
   1. 使用redis list 如果有缓存直接查找缓存
   2. 没有缓存就每次分页查询并存入缓存中，设置过期时间为1小时
   3. 线程安全的 设置成了synchronized <mark>这时为啥？ 需不需要设置随机的过期时间
      更新后：采用了分布式锁解决 提高并发性
4. 聊天模块的私聊消息
   1. 连接建立是查询是否有缓存，有缓存直接读取缓存
   2. 没有缓存查询数据库并存入缓存中
   3. 这里真的有必要吗 ？有必要，如果用户不聊天只是多次查看聊天记录，是可以提升速度和体验的
   4. <mark>解决雪崩问题：通过设置均匀的过期时间来缓解雪崩效应
   5. todo:之后可以考虑先把消息缓存如redis，之后定时任务批量导入数据库
5. 加入队伍上锁/加好友上锁 和缓存预热的锁相同
6. 用户注册 是否需要限流？？电商更合适？Guava redisLimiterManager.doRateLimiter限流 <mark>[四种经典限流算法](https://juejin.cn/post/6967742960540581918)
7. <mark>加好友后删除recommend里的缓存，用了Guava的retryer重试机制，电商里购买物品更合适？


## v1.2.0版本优化
### aop
- 完成全局登录拦截
- 完成log日志输出
### redis缓存各种问题
1. 缓存穿透
    存在这个需求吗？针对比较具体的查询需要缓存穿透
参考 http://doc.ochiamalu.top/
2. 雪崩
3. 缓存穿透

### 页面优化
1. 系统名字修改
2. 图片修改

### 使用优先队列减少topN运算过程中的内存占用


### todo:加入头像上传和验证码注册功能


----
## 改进和思考
1. 连接池用的jdbc 可以之后替换成druid连接池
2. 查询的两种方式 内存和sql 数据量大的时候实际看哪个快用哪个 如果接近： 
   - 如果参数可以分析，根据用户的参数选择查询方式，比如标签数 大于某个值内存更快
   - 如果参数不可以分析，并且数据库连接足够内存足够，可以并发查询，谁先返回用哪个
   - sql与内存结合，比如用sql先过滤到一部分tag
   - **之后可以多放数据选择合适的**
3. java8 parallelStream 去了解一下
4. session 和 cookie区别 还可以自己设置token存储在redis中和加在请求头里
5. session存在redis中什么时候进行删除清理库  **目前解决方案：设置过期时间解决 但是还未解决**
6. 对比之前request.getSession().setAttribute(USER_LOGIN_STATE, safetyUser)
的实现方式和换成redis存储的方式
7. jwt和session比较 https://www.cnblogs.com/ls1519/p/13428380.html 
8. 设置用户权限的方式  spring security 没必要用 细粒度权限控制
9. 主页推荐 是直接预先算好还是实时计算
10. 对比spring redis  jedis  redisson(分布式) 
11. 逻辑删除的优点
12. 队伍列表查询扩展到查询队伍所有成员的信息
13. 加入队伍 重复加入队伍问题 疯狂点击还是可能加入 分布式锁来解决
14. 根据加入队伍来实现匹配？可以进一步实现，考虑knn实现的算法
15. 思考推荐算法，可以思考一下大数据的排序策略 检索=》召回=》粗排=》精排
16. 使用邮箱注册 https://blog.csdn.net/qq_42263280/article/details/129584017
17. 可以定义一个专门刷新redis的拦截器
18. aop 拦截器 的区别？？项目中用的aop
19. redis更新和数据库更新加事务管理：recommend中加入了线程安全 思考缓存更新策略
20. 思考recommend 推荐策略 不能每次都一样吧 心动模式可以有好友吗
21. 学习事务失效的情况 比如this.method()
22. 推荐接口的优化？使用优先队列进行优化




# 伙伴匹配系统面向简历

## 相似度匹配部分改进
80w数据测试情况
改进之前 2.58s
经过测试，基本上大部分时间都是用来查询数据库所有信息 总共需要 2553ms
1. 用插入排序 只维护top n用户 改了之后变成2.55s
2. 不从数据库中加载所有的用户，只随机加载部分用户
   - 找部分用户的top n
   - 如果top n中相似度最小的得分达到阈值 就可以直接返回
   - 否则继续加载用户
   - 数据库查询阶段只用了634ms（单次查询就可以达到阈值要求的情况
最终查询优化：时间964ms

## 缓存预热
- 需求分析：recommend是用户首页，并且加载变化不是很大，可以考虑缓存预热
- 缓存预热改成和recommend同步，存储的是stringList类型的json数据，可以和recommend的下拉功能匹配

## redis 问题优化

**缓存穿透：**
> 客户端请求的数据在缓存中和数据库中都不存在，都会请求到数据库
场景：
- 用户登录，用户不存在如果一直请求会导致数据库压力过大

解决方案：
- 缓存空对象：数据库不存在之后写入空对象到缓存中，
- 布隆过滤器：客户端和redis之间存在一个布隆过滤器，用于判断请求的数据是否存在✅
- 主动防御：
  - 增加id的复杂度，不让敌手轻易伪造
  - **做好热点参数的限流**
  - 加强用户权限校验

步骤：
- 引入pom依赖 redisson
- 配置redisson.config
- 配置布隆过滤器
- 配置aop切面 在直接通过id获取用户和队伍的接口配置布隆过滤器
- 在新增队伍和用户的模块同时加入布隆过滤器
- 配置定时任务，定时更新布隆过滤器 每晚3点更新
- bloom在删除和重新充值时（即定时任务的时候） 数据量比较大的时候会比较耗时，可以考虑加锁 现在就不考虑了
  - job开始删除、重新充值bloom filter里的值时使用redission自续约锁上锁；
  - 每次判断用户请求进来和bloom filter里的值进行比对前先去拿一下redis锁；
  - 如果此时已经锁住，放过请求；
  - 如果拿不到锁，走正常redis bloom filter的拦截逻辑；

## 引入ES实现位置信息存储和查找
需求分析：用户可以根据位置信息查找附近的用户
参考：
https://cloud.tencent.com/developer/article/1442673
https://blog.csdn.net/qq_26545503/article/details/106461821

### 技术对比
#### 基本知识
世界上标识一个位置，通用的做法就使用经、纬度。经度的范围在 (-180, 180]，纬度的范围 在(-90, 90]

**GeoHash**
- 定位一个位置最好的办法就是用经、纬度标识，但经、纬度它是二维的，在进行位置计算的时候还是很麻烦
- 如果能通过某种方法将二维的经、纬度数据转换成一维的数据，那么比较起来就要容易的多，因此GeoHash算法应运而生
- GeoHash算法将二维的经、纬度转换成一个字符串
  - GeoHash字符串越长，表示的位置越精确，字符串长度越长代表在距离上的误差越小
  - 字符串越相似表示距离越相近，字符串前缀匹配越多的距离越近
  - 具体原理：https://cloud.tencent.com/developer/article/1442636
  - 把地球划分成小格子，用二分来进行划分，然后用二进制来表示
- 存在问题：两个点距离近但是在不同划分的格子里，反而距离远
  - 一般我们在业务中使用geohash的时候，一般不会仅仅使用一块区域的geohash，而是顺带将该区域周遭的八个区域也带上一起查询；在查询完后完毕出来结果后，还需要进行结果进行距离运算，然后按照距离进行排序

#### mysql
1. 不用geohash算法：存储经纬度，先查询出正方形区域，之后计算区域的点到用户的距离，找出r半径内的用户
   - 简单
   - 需要大量计算
2. MySQL + GeoHash：根据用户经、纬度属性计算出相应的GeoHash字符串，geohash字符串保存到MySQL数据库里，然后通过MySQL的like去模糊匹配geohash前缀

#### Redis + geohash
- 读多写少的场景，可以用redis进行加速
- 用到了有序队列zset以及geohash编码的数据结构
- 原理：https://cloud.tencent.com/developer/article/1526950
  - Redis内部使用有序集合(zset)保存位置对象，有序集合中每个元素都是一个带位置的对象，元素的score值为其经纬度对应的52位的geohash值
  - 查找附近的人要查找9宫格，每个格子里的对象在跳表里是挨着的，不同的格子不一定挨着

#### MongoDB+2d索引
- 两种地理空间索引 2dsphere 和 2d，可以看成是存储的geohash 
  - 2dsphere 索引仅支持球形表面的几何形状查询。
  - 2d 索引支持平面几何形状和一些球形查询。虽然2d 索引支持某些球形查询，但 2d 索引对这些球形查询时，可能会出错。所以球形查询尽量选择 2dsphere索引。
  - 都用geoJSON的标准格式来描述
  - https://www.cnblogs.com/sheseido/p/9807779.html
- 请求频繁可能操作超时连接问题 mongodb会随数据量的增加在地理位置查询时性能会急剧下降

#### ElasticSearch
- 多条件搜索强
- geopoint Elasticsearch的默认等级是9，也就是精准到4.8米左右
- 具体实现的发展过程：https://www.cnblogs.com/vivotech/p/16405981.html
  - es2.0版本：经纬度矩形初始筛查 之后计算两点距离精筛查， 缺点：筛查的记录太多了
  - es2.2版本：基于四叉树(Quadtree)的地理位置查询(Lucene 5.3版本实现)
    - morton编码：将二维坐标转换成一维坐标，和geohash类似 TODO:只用实现前缀匹配
    - 划分所查找的矩形区 => 用Quadtree进行矩形区域初筛 => 经纬度计算距离精筛
  - es5.0版本：**bkd-tree**独立索引 https://blog.csdn.net/weixin_43265851/article/details/119246595
    - 将N维点集合形成的矩形空间(southWest,northEast)递归分割成更小的矩形空间。跟常见的kd-tree不同，当分割到网格区域里面坐标点的数量小于一定数量(比如1024)就停止了 => 来保证划分成差不多大的矩形区域
    - 生成待查询矩形区域 => 查询bkd-tree索引叶子结点的位置关系 => 计算两点间的距离

#### postgis 
- 一个空间数据库
- 
#### 总结
实现方法：
- 不用任何数据结构 mysql
- 用geohash算法 mysql redis  -> 先计算网格登记，再多计算周围的8个区域，之后计算距离精筛
- 用bkd-tree算法 es -> 生成待查询矩形区域 => 查询bkd-tree索引叶子结点的位置关系 => 计算两点间的距离
- 用2d索引 mongodb -> R树
 


### 主要开发流程

#### 1. 安装es并在springboot中引入es
注意版本对应

springboot2.6  对应es7.15.2 ik分词器7.15.2 kibana7.15.2

https://www.cnblogs.com/DeepInThought/p/18178316

pom.xml中引入starter-data-elasticsearch
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>
```
直接用 ElasticsearchRestTemplate操作

#### 2. 实现es数据导入和查询过程
- 可以从es中查到数据
   - GeoPointField注释不起作用，需要自己在es中定义索引结构
- 数据库插入、删除、更改数据后需要同步到es中
  - 单独定义了一个数据库用来进行es的数据同步和测试 `partner_es`
  - 用户的地理位置信息需要同步到es中,需要改的部分
    - 用户注册 ✅
    - 用户修改信息 因为用户不能修改地理位置信息，所以可以考虑不对es进行同步
    - 用户删除信息 目前前端没有用到这个接口
    - 用户查询信息
      - 按照距离查询 ✅
      - 推荐用户/标签推荐 都需要显示用户的距离关系 （自己单独写一个模块算会不会比较快）
      - TODO: 最匹配可以改成距离和标签一起来匹配
  
#### 3. 基于消息队列的数据同步
https://blog.csdn.net/m0_68681879/article/details/132837139




### 需要完善的：
1. 心动模式数据为空
2. 好友列表显示还是距离为null
3. 加载还是有问题，可能需要改成sync
4. 更新队伍 
5. 会保存admin的布隆过滤器
6. 位置信息没有更新

问题：遇到只有chrome可以正确跳转  其他浏览器不能保存cookie
cookie domain 设置问题
设置yml配置文件中的 domain: www.joinfun.online



TODO:用户修改了信息之后，推荐列表是不是就要更新了？？？ 可以第一次加载的时候去数据库查看 返回结果的同时进行更新


TODO:缓存更新策略，选用帮路缓存策略的出现的问题及解决 比如订阅mysql binlog

![alt text](../../../../科研/学习/项目/image.png)


