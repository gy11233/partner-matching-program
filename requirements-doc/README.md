# 伙伴匹配系统

## 需求分析
1. 用户添加标签，标签的分类
2. 主动搜索：用户更加标签搜索其他用户
    1. redis缓存
3. 组队：创建队伍，加入队伍，查询队伍，邀请其他人
4. 允许用户修改标签
5. 推荐： 相似度计算算法+本地分布式计算


## 技术栈
### 前端
1. Vue3 开发框架
2. Vant UI
3. Vite 打包工具
4. Nginx单机部署

### 后端
1. java编程语言+springboot框架
2. springMVc + Mybatis + MyBatis Plus
3. MySQL数据库
4. Redis缓存
5. Swagger + Knife4j接口文档


## 主要流程

### 第一期任务
1. 数据库表设计
   1. 标签表
   2. 用户表
2. 开发后端 根据标签搜索用户
3. 后端整合Swagger+Knife4j接口文档
4. 存量用户信息导入
5. 前后端联调 使用@CrossOrigin注解

### 第二期任务
1. 页面和功能开发 前端
2. 改造用户中心，把单机登录改成分布式session登录

### 第三期任务
1. 用户修改页面的后端开发
2. 开发主页（默认推荐和自己兴趣相当的用户）
   - 开发/user/recommend后端接口
   - 导入数据 尽量一个量级一个量级增加 分批导入 写程序导入 更可控
3. 优化主页的性能（缓存+定时任务）

### 第四期任务
1. 分布式锁

### 第五期任务
1. 组队功能


## 模块实现

### 数据库表设计

#### 1. 标签表
建议用标签不用分类 更加灵活

**标签的设计**
性别：男女  
方向：java  c++ go  
目标： 考研 求职 球招 社招 考公 竞赛  
段位： 入门 中级 高级  
身份： 大一 大二 大三 大四 研一 研二 研三   
状态： 单身 已婚 有对象
【用户自己定义标签】
如果标签固定的 是不是可以直接存在后端？？？

**字段**

id int 主键   
标签名 varchar 非空 （**必须唯一 唯一索引**）
上传标签的用户id user_id int  （如果要要根据userid查看已经上传标签的话，最好加上 普通索引）
父标签id parent_id int  
是否为父标签 is_parent tinyint(0, 1) **尽量不要用布尔 不灵活**  
创建时间 create_time   datetime
更新时间 update_time   datetime
是否删除 is_delete tinyint(0,1)

考虑的问题 怎么查询标签并分组？ 按照父标签id分组
根据父标签查询子标签？查服标签的id

标签字段设计的一般都有的属性
id 创建时间 更新时间 是否删除

#### 2. 用户表
用户可以知道有哪些标签 一对多的关系
   1. 用户表中加tags标签 【‘java’, '男'】存json字符串 ✅
      - 优点：查询用户标签比较方便 不用新建关联表，（标签是固有属性 除了系统其他系统页可能用）
        之后随着人数增多 20w+ 效率低了 也可以考虑用缓存的技术来缓存java标签下的所有用户
      - 缺点：通过标签查询用户不方便 用like效率很低 更新用户表或者更新标签很麻烦
   2. 关联表 记录用户和标签的关系 
      - 优点：正反查都很方便
      - 重点：企业大型项目开发中尽量减少关联查询，会应用查询系统

**字段**

id bigint 自增 主键  
用户昵称 username varchar  
用户账号 user_account  
用户头像 user_url  
用户性别 gender  
用户密码 password varchar  
电话 phone  
邮箱 email  
用户状态 user_status  
创建时间 create_time   datetime  
更新时间 update_time   datetime  
是否删除 is_delete tinyint(0,1)  
用户角色 user_role  
星球编号 planet_code  
标签 tags  varchar(1024)


### 主要功能

#### 用户中心提供用户检索 登陆 修改 鉴权
TODO: 细致分析用户中中心


#### 通过标签搜索用户功能
1. 允许用户输入标签，多个标签都存在才搜索出来 and  like "%java%" and like "%C++" 
2. 允许用户传入多个标签，只要有一个就搜索出来 or  like "%java%" or like "%C++"

两种查询方法：
1. sql查询
2. 内存查询MybatisX-Generator插件生成关于表的基本代码

> tips:可以通过MybatisX-Generator操作

**实现思路**
service实现 `searchUsersByTags`
- 标签不能为空 否则返回异常
- 用sql的方式实现
- 用内存的方式实现（可以通过并发）

#### 用户注册 登陆 （解决分布式登录问题）
模拟分布式登录：
```shell
java -jar 项目jar包 --server.port=8081
```
##### 服务器A登录后，请求发送到服务器B不认识用户
用户在A登录，所以session存储在了A中，请求B时，B没有用户信息
解决方案：共享存储，把用户信息放在**公共存储**中
如何共享存储？
1. mysql
2. redis ✅ 用户信息读取/是否登录的判断及其**频繁** 基于内存 读写性能很高 单机qps 5w-10w
3. 文件服务器 ceph

##### redis安装与使用
> https://blog.csdn.net/realize_dream/article/details/106227622

版本 redis 7.2.5 
管理工具 quick redis 

基本命令:
```shell
brew services start redis
redis-cli
redis-cli -h 127.0.0.1 -p 6379
redis-cli shutdown
```
引入mvn包 
配置application.yml
- 配置redis
- 配置session存储方式为redis store-type: redis 从redis中读写session

#### 修改用户信息
1. 判断参数是否为空
23可以写到service层
2. 校验权限
3. 触发更新

----
### 后端整合Swagger+Knife4j接口文档
每条接口内容
- 请求参数
- 响应参数
  - 错误码
- 接口地址
- 接口名称
- 请求类型
- 请求格式
- 备注

swagger https://blog.csdn.net/hadues/article/details/123753888
1. maven中引入
2. 配置config下文件 在SwaggerConfig类上加@Profile({"dev", "test"})注解 不暴露接口给外部
3. 配置需要生成接口文档的包
4. 配置application.yml(因为版本兼容带来的问题)

### 批量导入数据
1. 写程序导入
2. 用mybatis-plus的批量导入加速
3. 数据量大了之后采用分页操作显示主页信息

### 主页性能优化
80w数据用了分页之后还是0.2s 有卡顿，如果超出1s就是比较慢的 数据库慢 
预先把数据查出来放到一个更快读取的地方（缓存）

预加载 定时更新缓存  分布式锁 控制同一时间只有一台及其去执行定时任务

##### 数据查询慢怎么办？用缓存
缓存：提前把数据取出来保存好，通常保存到读写更快的介质中，比如内存

**缓存的实现**
- redis 分布式
- memcached 分布式
- etcd  云原生架构的分布式存储 存储配置 扩容能力强
------
- ehcache 单机
- 本地缓存 java内存map
- caffeine java内存缓存 高性能
- google guava
单机缓存 在多服务器的时候可能出现数据不一致的情况

**redis**
> NoSQL数据库

key-value存储系统

**java里的实现方式**
- spring data redis (推荐)
  - spring data一组通用的数据访问框架，定义了增删改查的接口
  - spring data redis是针对redis的实现类
- jedis
- redisson

###### 具体实现
1. **设计缓存key**
    systemId:moduleId:func:<options> (不和别人冲突)
    
    partner:user:recommend:userId 
2. **实现redis缓存存储** 
   - 如果没有登录的直接用default，登录的用户记录自己的缓存（之后可以扩展成有匹配的推荐）
   - 效果：没有用redis之前加载时间200ms左右 改进后第一个用户200ms，之后的用户20ms左右
   - 问题：第一个用户还是很慢

#### 缓存预热
###### 缓存预热优缺点
- 优点
  - 让用户始终访问很快
- 缺点
  - 增加开发成本
  - 预热的时间和时机如果错了，可能缓存的数据不对
  - 需要占用额外空间
###### 怎么缓存预热
- 定时
  - 启动类@EnableScheduling 需要定时执行的方法添加@Scheduled，指定corn表达式
- 模拟触发（手动触发）
- 注意的点
  - 缓存预热的意义 （新增少，总用户多）
  - 缓存的空间不能占有太大，要预留给其他缓存空间
  - 预热周期 1/天
###### 定时任务实现
1. spring scheduler  springboot 默认整合
2. quartz 独立于Spring的定时任务
3. XX-job ==可以放在后续实现和源码阅读任务==


#### 分布式锁 控制定时任务的执行
可能出现脏数据（重复插入） 浪累资源

**控制定时任务在同一时间只有一个服务器执行**

可能方法：
- 分离定时任务和主程序，只在一个服务器运行定时任务  成本比较大
- 写死配置，每个服务器都执行定时任务，但只有ip符合配置的服务器才真正执行业务逻辑 成本低 但是ip可能是不固定的，改起来很麻烦
- 动态配置，但只有ip符合配置的服务器才真正执行业务逻辑，配置可以很方便更新(代码无需重启)
  - 数据库
  - Redis
  - 配置中心（Nacos, Apollo, Spring Cloud Config）
  问题 服务器多了还是需要修改
- 分布式锁，只有抢到锁的服务器才能真正执行定时任务业务逻辑  增加成本 但是不用手动配置，多少服务器都一样

**实现方法**

java实现锁：synchronized 关键字  
问题：只对单个JVM有效

**为啥需要分布式锁**
1. 有限资源情况下，控制同一时间（段）只有某些线程（用户或者服务器）可以访问到资源
2. 单个锁只对单个JVM有效

##### 分布式锁实现的关键
**抢锁机制** 同一时间只有一个用户可以抢到锁

数据库实现：先来的人先把数据改成自己的标识（服务器ip）后来的人发现标识已经存在，就抢锁失败，继续等待

- zookeeper实现 （不推荐）
- MySQL数据库：select for update行级锁  ==乐观锁==自己后面考虑
- Redis:读写速度快，支持**setnx** lua脚本 ✅

**Redis实现注意的问题**
1. 用完锁释放
2. 锁**一定**要加过期时间
3. 如果方法执行中锁提前过期？
   - 还是会出现多个方法同时执行的情况
   - 连锁效应：释放了别人的锁
    解决方案：续期
4. 释放锁的时候，先判断了是自己的锁，如果锁过期，还是可能释放其他人的锁
5. Redis是集群的情况，如果保证数据一致？ 红锁

**Redis+lua脚本实行** 保证原子操作

##### Redisson实现分布式锁
java客户端，数据网络 
实现了很多java里支持的接口和数据接口 

Redisson是一个java操作Redis的客户端，提供了大量分布式数据集来简化对Redis的操作和使用，
可以让开发者像是使用本地集合一样操作Redis，完全感知不到Redis存在

partner:precachejob:docache:lock

- waitTime设置为0 只抢一次
- 释放锁写在finally里
- redisson提供了续期机制->看门口机制 开一个监听线程，如果方法没执行完自动帮助续期(debug模式会当成宕机 不会续期)


### 组队功能

#### 需求分析
理想应用场景：和别人一起参加竞赛或者做项目，可以发起队伍或者加入别人的队伍

用户可以创建一个队伍，设置队伍的任务、名称（标题）、描述、超时  p0
> 队长、剩余的任务
> 聊天
> 公开 ｜ 加密 ｜私有
> 不展示过期的队伍
> **一个人最多可以创建5个人**

展示队伍列表，根据标签或者名称搜索队伍 p0

修改队伍信息

用户可 以加入队伍（其他人 未满 未过期 ） 允许加入多个队伍，但是要有个上限 p0
> 是否需要队长同意？审批

用户可以退出队伍（如果是队长退出，权限转移给第二个加入的用户） p1 
队长可以解散队伍  p0 
分享队伍，邀请其他人加入队伍 p1



#### 实现
库表设计

增删改查

业务逻辑开发

#### 库表设计
队伍表 team
字段：
- id主键 bigint （连续 放url上比较间断 但是怕爬虫）
- name 队伍名称
- description描述
- max_num 最大人数
- expire_time 过期时间
- user_id 用户id
- status 0-公开 1-私有 2-加密
- password 密码
- create_time 创建时间
- update_time
- is_delete

用户-队伍表 user_team
字段
- id主键
- user_id 用户id
- team_id 队伍id
- join_time 加入时间
- create_time 创建时间
- update_time
- is_delete


两个关系
1. 用户加了哪些队伍
2. 队伍有哪些用户

方式
1. 建立用户-队伍关系表 （便于修改，查询性能高一点） ✅
2. 用户表补充已经加入的队伍字段，队伍表补充已经加入的用户字段 （不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）


#### 后端代码完成

##### 为什么需要请求参数包装类
- 请求参数名称/类型和实体类型不一样
- 有一些参数用不到，如果自动生成接口文档增加理解成本
- 多个字段映射到同一个对象

##### 为什么要包装类
- 可能有些字段需要隐藏，不能返回给前端
- 有些字段的某些方法是不关心的

#### 接口设计

##### 创建队伍
用户可以创建一个队伍，设置队伍的任务、名称（标题）、描述、超时  p0
> 队长、剩余的任务
> 聊天
> 公开 ｜ 加密 ｜私有
> 不展示过期的队伍

1. 请求参数是否为空
2. 是否登录 不登录不允许创建
3. 校验信息
   1. 队伍人数>1 <=20
   2. 队伍标题<=20
   3. 描述 <=512
   4. status是否公开  不传默认公开
   5. status如果是加密状态一定要有密码 且密码<=32
   6. 超时时间 > 当前时间
   7. 校验用户最多创建5个队伍
4. 插入队伍信息到队伍表
5. 插入 队伍用户信息到 关系表

通过@Transactional(rollbackFor = Exception.class)注解，进行事务操作，只有队伍信息插入成功 关系表才会同步更新

### 随机匹配





> 分析优缺点要从整个项目从0-1进行分析

----
## 改进和思考
1. 连接池用的jdbc 可以之后替换成druid连接池
2. 查询的两种方式 内存和sql 数据量大的时候实际看哪个快用哪个 如果接近： 
   - 如果参数可以分析，根据用户的参数选择查询方式，比如标签数 大于某个值内存更快
   - 如果参数不可以分析，并且数据库连接足够内存足够，可以并发查询，谁先返回用哪个
   - sql与内存结合，比如用sql先过滤到一部分tag
   - **之后可以多放数据选择合适的**
3. java8 parallelStream 去了解一下
4. session 和 cookie区别
5. session存在redis中什么时候进行删除清理库  **目前解决方案：设置过期时间解决 但是还未解决**
6. 对比之前request.getSession().setAttribute(USER_LOGIN_STATE, safetyUser)
的实现方式和换成redis存储的方式
7. jwt和session比较 https://www.cnblogs.com/ls1519/p/13428380.html 
8. 设置用户权限的方式  spring security 没必要用 细粒度权限控制
9. 主页推荐 是直接预先算好还是实时计算
10. 对比spring redis  jedis  redisson(分布式) 
11. 逻辑删除的优点
